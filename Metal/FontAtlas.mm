// FontAtlas.mm
// SuperTerminal v2.0 - Font Atlas Management Implementation
// Phase 1 Week 2: Bitmap font loading and texture atlas generation

#import "FontAtlas.h"
#import <Foundation/Foundation.h>
#import <AppKit/AppKit.h>
#import <CoreText/CoreText.h>
#import <CoreGraphics/CoreGraphics.h>
#include <array>
#include <cmath>

namespace SuperTerminal {

// =============================================================================
// Built-in VGA 8x16 Font Data
// =============================================================================
// Classic VGA font used in DOS and early PCs
// Contains ASCII characters 0-255 (CP437 encoding)

static const uint8_t VGA_8x16_FONT_DATA[] = {
    // Character 0x00 (NULL)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x01 (☺)
    0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0x81, 0xBD,
    0x99, 0x81, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00,

    // Character 0x02 (☻)
    0x00, 0x00, 0x7E, 0xFF, 0xDB, 0xFF, 0xFF, 0xC3,
    0xE7, 0xFF, 0xFF, 0x7E, 0x00, 0x00, 0x00, 0x00,

    // Character 0x03 (♥)
    0x00, 0x00, 0x00, 0x00, 0x6C, 0xFE, 0xFE, 0xFE,
    0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,

    // Character 0x04 (♦)
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE,
    0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x05 (♣)
    0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0xE7, 0xE7,
    0xE7, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    // Character 0x06 (♠)
    0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF,
    0x7E, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,

    // Character 0x07 (•)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C,
    0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x08-0x1F (control characters - simple blocks)
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x20 (SPACE)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x21 (!)
    0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18,
    0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    // Character 0x22 (")
    0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x23 (#)
    0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C,
    0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,

    // Character 0x24 ($)
    0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06,
    0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00,

    // Character 0x25 (%)
    0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18,
    0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00,

    // Character 0x26 (&)
    0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,

    // Character 0x27 (')
    0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x28 (()
    0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,

    // Character 0x29 ())
    0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C,
    0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,

    // Character 0x2A (*)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF,
    0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x2B (+)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E,
    0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x2C (,)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,

    // Character 0x2D (-)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x2E (.)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    // Character 0x2F (/)
    0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18,
    0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,

    // Characters 0x30-0x39 (0-9)
    // 0
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xCE, 0xDE, 0xF6,
    0xE6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 1
    0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // 2
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30,
    0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // 3
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06,
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 4
    0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE,
    0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00,
    // 5
    0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06,
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 6
    0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 7
    0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18,
    0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
    // 8
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 9
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06,
    0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00,

    // 0x3A (:)
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0x3B (;)
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
    // 0x3C (<)
    0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60,
    0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00,
    // 0x3D (=)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00,
    0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0x3E (>)
    0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06,
    0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,
    // 0x3F (?)
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18,
    0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // 0x40 (@)
    0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE,
    0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00,

    // Characters 0x41-0x5A (A-Z)
    // A
    0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // B
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66,
    0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,
    // C
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0,
    0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // D
    0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66,
    0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00,
    // E
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68,
    0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // F
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68,
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // G
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE,
    0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00,
    // H
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // I
    0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // J
    0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
    0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
    // K
    0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78,
    0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // L
    0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60,
    0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // M
    0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // N
    0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // O
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // P
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60,
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // Q
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00,
    // R
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C,
    0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // S
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C,
    0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // T
    0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // U
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // V
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    // W
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6,
    0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00, 0x00,
    // X
    0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x38,
    0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // Y
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Z
    0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30,
    0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,

    // 0x5B ([)
    0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // 0x5C (\)
    0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38,
    0x1C, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
    // 0x5D (])
    0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
    0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // 0x5E (^)
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0x5F (_)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
    // 0x60 (`)
    0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Characters 0x61-0x7A (a-z)
    // a
    0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // b
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66,
    0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // c
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0,
    0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // d
    0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // e
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE,
    0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // f
    0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60,
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // g
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00,
    // h
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66,
    0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // i
    0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // j
    0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00,
    // k
    0x00, 0x00, 0xE0, 0x60, 0x00, 0x66, 0x6C, 0x78,
    0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // l
    0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // m
    0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6,
    0xD6, 0xD6, 0xD6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // n
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66,
    0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    // o
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // p
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66,
    0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
    // q
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00,
    // r
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66,
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // s
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0,
    0x7C, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // t
    0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30,
    0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,
    // u
    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // v
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
    // w
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6,
    0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00,
    // x
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38,
    0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // y
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00,
    // z
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18,
    0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,

    // 0x7B ({)
    0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18,
    0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,
    // 0x7C (|)
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // 0x7D (})
    0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18,
    0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,
    // 0x7E (~)
    0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0x7F (DEL - block)
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6,
    0xC6, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,

    // Character 0x30-0x39 (0-9)
    // 0
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xCE, 0xD6, 0xD6,
    0xE6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 1
    0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // 2
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30,
    0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // 3
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06,
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 4
    0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE,
    0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00,
    // 5
    0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06,
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 6
    0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 7
    0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18,
    0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
    // 8
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 9
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06,
    0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00,

    // Character 0x3A (:)
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x3B (;)
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,

    // Character 0x3C (<)
    0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60,
    0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00,

    // Character 0x3D (=)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00,
    0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x3E (>)
    0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06,
    0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,

    // Character 0x3F (?)
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18,
    0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    // Character 0x40 (@)
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE,
    0xDC, 0xC0, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00,

    // Character 0x41-0x5A (A-Z)
    // A
    0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // B
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66,
    0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,
    // C
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0,
    0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // D
    0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66,
    0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00,
    // E
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68,
    0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // F
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68,
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // G
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE,
    0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00,
    // H
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // I
    0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // J
    0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
    0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
    // K
    0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78,
    0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // L
    0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60,
    0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // M
    0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // N
    0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // O
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // P
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60,
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // Q
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00,
    // R
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C,
    0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // S
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C,
    0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // T
    0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // U
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // V
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    // W
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6,
    0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00, 0x00,
    // X
    0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x38,
    0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // Y
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Z
    0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30,
    0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,

    // Character 0x5B ([)
    0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00,

    // Character 0x5C (\)
    0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38,
    0x1C, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,

    // Character 0x5D (])
    0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
    0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00,

    // Character 0x5E (^)
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x5F (_)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,

    // Character 0x60 (`)
    0x00, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x61-0x7A (a-z)
    // a
    0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // b
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66,
    0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // c
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0,
    0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // d
    0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // e
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE,
    0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // f
    0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60,
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // g
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00,
    // h
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66,
    0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // i
    0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // j
    0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00,
    // k
    0x00, 0x00, 0xE0, 0x60, 0x00, 0x66, 0x6C, 0x78,
    0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // l
    0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // m
    0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6,
    0xD6, 0xD6, 0xD6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // n
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66,
    0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    // o
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // p
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66,
    0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
    // q
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00,
    // r
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66,
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // s
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0,
    0x7C, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // t
    0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30,
    0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,
    // u
    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // v
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
    // w
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6,
    0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00,
    // x
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38,
    0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // y
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00,
    // z
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18,
    0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,

    // Character 0x7B ({)
    0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18,
    0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,

    // Character 0x7C (|)
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,

    // Character 0x7D (})
    0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18,
    0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,

    // Character 0x7E (~)
    0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Character 0x7F (DEL) - filled block
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6,
    0xC6, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// Number of characters in VGA font (ASCII 0-127 for now)
static const int VGA_FONT_CHAR_COUNT = 128;
static const int VGA_FONT_GLYPH_WIDTH = 8;
static const int VGA_FONT_GLYPH_HEIGHT = 16;

// =============================================================================
// Constructor / Destructor
// =============================================================================

FontAtlas::FontAtlas(id<MTLDevice> device)
    : device_(device)
    , texture_(nil)
    , glyphWidth_(0)
    , glyphHeight_(0)
    , atlasWidth_(0)
    , atlasHeight_(0)
    , firstChar_(0)
    , lastChar_(0)
    , isMonospace_(true)
    , glyphsPerRow_(0)
    , glyphRows_(0)
{
}

FontAtlas::~FontAtlas() {
    texture_ = nil;
}

// =============================================================================
// Font Loading
// =============================================================================

bool FontAtlas::loadBuiltinFont(const std::string& name) {
    if (name == "vga_8x16") {
        return loadVGA8x16Font();
    }
    if (name == "default") {
        // Default is now Unscii font
        return loadDefaultUnsciiFont();
    }
    // Check if it's an Unscii variant
    if (name == "unscii-8" || name == "unscii-16" || name == "unscii-16-full") {
        return loadUnsciiFont(name);
    }
    return false;
}

bool FontAtlas::loadBitmapFont(const uint8_t* pixels, int width, int height,
                              int glyphWidth, int glyphHeight,
                              uint32_t firstChar, uint32_t lastChar) {
    if (!pixels || width <= 0 || height <= 0 || glyphWidth <= 0 || glyphHeight <= 0) {
        return false;
    }

    glyphWidth_ = glyphWidth;
    glyphHeight_ = glyphHeight;
    firstChar_ = firstChar;
    lastChar_ = lastChar;

    // Create texture directly from bitmap
    return createTexture(pixels, width, height, MTLPixelFormatR8Unorm);
}

bool FontAtlas::loadTrueTypeFont(const std::string& path, int pixelSize) {
    @autoreleasepool {
        NSLog(@"FontAtlas: Loading font - trying Unscii first, then pre-rendered atlas");

        // First try to load Unscii fonts (preferred)
        if (loadDefaultUnsciiFont()) {
            return true;
        }

        NSLog(@"FontAtlas: Unscii not available, trying pre-rendered bitmap atlas");

        // Try to load pre-generated bitmap atlas first
        NSBundle* bundle = [NSBundle mainBundle];
        NSString* atlasPath = [[bundle resourcePath] stringByAppendingPathComponent:@"font_atlas_jetbrains_mono_9x18_medium_14pt.png"];

        if ([[NSFileManager defaultManager] fileExistsAtPath:atlasPath]) {
            NSLog(@"FontAtlas: Found pre-rendered atlas at: %@", atlasPath);

            // Load PNG image
            NSImage* image = [[NSImage alloc] initWithContentsOfFile:atlasPath];
            if (image) {
                NSBitmapImageRep* bitmap = [[NSBitmapImageRep alloc] initWithData:[image TIFFRepresentation]];
                if (bitmap) {
                    int width = (int)[bitmap pixelsWide];
                    int height = (int)[bitmap pixelsHigh];
                    int bytesPerPixel = (int)[bitmap bitsPerPixel] / 8;
                    int bytesPerRow = (int)[bitmap bytesPerRow];
                    NSBitmapFormat format = [bitmap bitmapFormat];
                    int samplesPerPixel = (int)[bitmap samplesPerPixel];
                    BOOL isPlanar = [bitmap isPlanar];



                    // Extract grayscale data
                    std::vector<uint8_t> atlasData(width * height);
                    unsigned char* bitmapData = [bitmap bitmapData];

                    // Extract pixels based on format
                    for (int y = 0; y < height; y++) {
                        for (int x = 0; x < width; x++) {
                            int dstIdx = y * width + x;

                            // Handle different bitmap formats
                            if (samplesPerPixel == 1) {
                                // Pure grayscale
                                int srcIdx = y * bytesPerRow + x;
                                atlasData[dstIdx] = bitmapData[srcIdx];
                            } else {
                                // RGB or RGBA - take first channel
                                int srcIdx = y * bytesPerRow + x * bytesPerPixel;
                                atlasData[dstIdx] = bitmapData[srcIdx];
                            }
                        }
                    }

                    // Debug: Check if we extracted pixels for box drawing character
                    // U+2502 at index 97: row=6, col=1, position (16, 96)
                    int testY = 96;
                    int testX = 16;
                    int nonZeroCount = 0;
                    for (int dy = 0; dy < 16; dy++) {
                        for (int dx = 0; dx < 16; dx++) {
                            int idx = (testY + dy) * width + (testX + dx);
                            if (atlasData[idx] > 0) {
                                nonZeroCount++;
                            }
                        }
                    }

                    // Set dimensions from metadata
                    glyphWidth_ = 9;    // From font_atlas_jetbrains_mono_9x18_medium_14pt_metadata.h
                    glyphHeight_ = 20;
                    atlasWidth_ = width;
                    atlasHeight_ = height;
                    firstChar_ = 32;
                    lastChar_ = 126;
                    fontName_ = "JetBrains Mono Medium 14pt (8x18)";
                    isMonospace_ = true;

                    int glyphsPerRow = 16;

                    // Build character list: ASCII 32-126 + Box Drawing 0x2500-0x257F
                    std::vector<uint32_t> charList;

                    // Add ASCII printable characters
                    for (uint32_t i = firstChar_; i <= lastChar_; ++i) {
                        charList.push_back(i);
                    }

                    // Add box drawing characters
                    for (uint32_t i = 0x2500; i < 0x2580; ++i) {
                        charList.push_back(i);
                    }

                    int charCount = (int)charList.size();
                    glyphs_.clear();
                    glyphs_.reserve(charCount);
                    charMap_.clear();

                    // Generate glyph metrics and build character map
                    for (int i = 0; i < charCount; ++i) {
                        uint32_t codepoint = charList[i];

                        int row = i / glyphsPerRow;
                        int col = i % glyphsPerRow;

                        // Account for padding in atlas layout (13x24 padded cells, 2px padding)
                        int paddedCellWidth = 13;  // From metadata: FONT_PADDED_CELL_WIDTH
                        int paddedCellHeight = 24; // From metadata: FONT_PADDED_CELL_HEIGHT
                        int padding = 2;           // From metadata: FONT_ATLAS_PADDING

                        // Calculate position in padded atlas
                        int paddedStartX = col * paddedCellWidth;
                        int paddedStartY = row * paddedCellHeight;

                        // Actual glyph position (inside padding)
                        int startX = paddedStartX + padding;
                        int startY = paddedStartY + padding;

                        GlyphMetrics metrics;
                        metrics.width = glyphWidth_;
                        metrics.height = glyphHeight_;
                        metrics.bearingX = 0;
                        metrics.bearingY = glyphHeight_;
                        metrics.advance = glyphWidth_;
                        metrics.atlasX = static_cast<float>(startX) / atlasWidth_;
                        metrics.atlasY = static_cast<float>(startY) / atlasHeight_;
                        metrics.atlasWidth = static_cast<float>(glyphWidth_) / atlasWidth_;
                        metrics.atlasHeight = static_cast<float>(glyphHeight_) / atlasHeight_;

                        glyphs_.push_back(metrics);
                        charMap_[codepoint] = i;  // Map codepoint to glyph index
                    }

                    // Create Metal texture
                    bool success = createTexture(atlasData.data(), atlasWidth_, atlasHeight_, MTLPixelFormatR8Unorm);

                    if (success) {
                        return true;
                    }
                }
            }
        }

        NSLog(@"FontAtlas: Pre-rendered atlas not found, falling back to TrueType rendering");

        // Fallback to TrueType rendering
        CTFontRef font = CTFontCreateWithName(CFSTR("Menlo"), pixelSize, NULL);

        if (!font) {
            NSLog(@"FontAtlas: Failed to load Menlo, trying Monaco");
            font = CTFontCreateWithName(CFSTR("Monaco"), pixelSize, NULL);
        }

        if (!font) {
            NSLog(@"FontAtlas: Failed to load any font");
            return false;
        }

        // Get font metrics
        CGFloat ascent = CTFontGetAscent(font);
        CGFloat descent = CTFontGetDescent(font);
        CGFloat leading = CTFontGetLeading(font);

        glyphHeight_ = (int)ceil(ascent + descent + leading);

        // Get character width using 'M' as reference
        CGGlyph glyph;
        unichar m = 'M';
        CTFontGetGlyphsForCharacters(font, &m, &glyph, 1);
        CGSize advance;
        CTFontGetAdvancesForGlyphs(font, kCTFontOrientationDefault, &glyph, &advance, 1);
        glyphWidth_ = (int)ceil(advance.width);

        fontName_ = "System Monospace";
        isMonospace_ = true;
        firstChar_ = 32;
        lastChar_ = 126;
        int charCount = lastChar_ - firstChar_ + 1;

        // Calculate atlas dimensions
        calculateAtlasDimensions(charCount, glyphWidth_, glyphHeight_,
                               atlasWidth_, atlasHeight_);

        // Create atlas data
        std::vector<uint8_t> atlasData(atlasWidth_ * atlasHeight_, 0);

        // Clear and reserve glyph metrics
        glyphs_.clear();
        glyphs_.reserve(charCount);

        NSLog(@"FontAtlas: Rendering %d glyphs to %dx%d atlas", charCount, atlasWidth_, atlasHeight_);

        // Create bitmap context
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();
        CGContextRef context = CGBitmapContextCreate(
            atlasData.data(),
            atlasWidth_,
            atlasHeight_,
            8,
            atlasWidth_,
            colorSpace,
            kCGImageAlphaNone
        );
        CGColorSpaceRelease(colorSpace);

        if (!context) {
            CFRelease(font);
            NSLog(@"FontAtlas: Failed to create bitmap context");
            return false;
        }

        // Set rendering properties - disable antialiasing for pixel-perfect bitmap fonts
        CGContextSetTextMatrix(context, CGAffineTransformIdentity);
        CGContextSetShouldAntialias(context, false);
        CGContextSetShouldSmoothFonts(context, false);

        // Render each character
        for (int i = 0; i < charCount; ++i) {
            unichar character = (unichar)(firstChar_ + i);

            int row = i / glyphsPerRow_;
            int col = i % glyphsPerRow_;
            int startX = col * glyphWidth_;
            int startY = row * glyphHeight_;

            // Get glyph
            CGGlyph glyph;
            if (!CTFontGetGlyphsForCharacters(font, &character, &glyph, 1)) {
                continue;
            }

            // Draw glyph
            CGContextSetGrayFillColor(context, 1.0, 1.0);
            CGPoint position = CGPointMake(startX, atlasHeight_ - startY - glyphHeight_ + descent);
            CTFontDrawGlyphs(font, &glyph, &position, 1, context);

            // Store glyph metrics
            GlyphMetrics metrics;
            metrics.width = glyphWidth_;
            metrics.height = glyphHeight_;
            metrics.bearingX = 0;
            metrics.bearingY = glyphHeight_;
            metrics.advance = glyphWidth_;
            metrics.atlasX = static_cast<float>(startX) / atlasWidth_;
            metrics.atlasY = static_cast<float>(startY) / atlasHeight_;
            metrics.atlasWidth = static_cast<float>(glyphWidth_) / atlasWidth_;
            metrics.atlasHeight = static_cast<float>(glyphHeight_) / atlasHeight_;

            glyphs_.push_back(metrics);
        }

        CGContextRelease(context);
        CFRelease(font);

        // Create Metal texture
        bool success = createTexture(atlasData.data(), atlasWidth_, atlasHeight_, MTLPixelFormatR8Unorm);

        if (success) {
            NSLog(@"FontAtlas: Successfully loaded font - %dx%d cells, %d glyphs",
                  glyphWidth_, glyphHeight_, (int)glyphs_.size());
        }

        return success;
    }
}

bool FontAtlas::generateAtlas(const std::vector<std::vector<uint8_t>>& glyphs) {
    if (glyphs.empty()) {
        return false;
    }

    // Pack glyphs into atlas
    std::vector<uint8_t> atlasData = packGlyphsToAtlas(glyphs, glyphWidth_, glyphHeight_);

    // Create texture
    return createTexture(atlasData.data(), atlasWidth_, atlasHeight_, MTLPixelFormatR8Unorm);
}

// =============================================================================
// Glyph Metrics
// =============================================================================

GlyphMetrics FontAtlas::getGlyphMetrics(uint32_t codepoint) const {
    // Try character map first (for non-consecutive ranges like box drawing)
    if (!charMap_.empty()) {
        auto it = charMap_.find(codepoint);
        if (it != charMap_.end()) {
            return glyphs_[it->second];
        }
        // Not in map, return default
        GlyphMetrics metrics;
        metrics.width = glyphWidth_;
        metrics.height = glyphHeight_;
        metrics.bearingX = 0;
        metrics.bearingY = 0;
        metrics.advance = glyphWidth_;
        metrics.atlasX = 0.0f;
        metrics.atlasY = 0.0f;
        metrics.atlasWidth = 0.0f;
        metrics.atlasHeight = 0.0f;
        return metrics;
    }

    // Fallback to simple range check (for old consecutive fonts)
    if (codepoint < firstChar_ || codepoint > lastChar_) {
        // Return default metrics for missing glyph
        GlyphMetrics metrics;
        metrics.width = glyphWidth_;
        metrics.height = glyphHeight_;
        metrics.bearingX = 0;
        metrics.bearingY = 0;
        metrics.advance = glyphWidth_;
        metrics.atlasX = 0.0f;
        metrics.atlasY = 0.0f;
        metrics.atlasWidth = 0.0f;
        metrics.atlasHeight = 0.0f;
        return metrics;
    }

    size_t index = codepoint - firstChar_;
    if (index < glyphs_.size()) {
        return glyphs_[index];
    }

    // Calculate metrics for grid-based fonts
    GlyphMetrics metrics;
    metrics.width = glyphWidth_;
    metrics.height = glyphHeight_;
    metrics.bearingX = 0;
    metrics.bearingY = glyphHeight_;
    metrics.advance = glyphWidth_;

    // Calculate atlas coordinates
    int row = static_cast<int>(index) / glyphsPerRow_;
    int col = static_cast<int>(index) % glyphsPerRow_;

    metrics.atlasX = static_cast<float>(col * glyphWidth_) / static_cast<float>(atlasWidth_);
    metrics.atlasY = static_cast<float>(row * glyphHeight_) / static_cast<float>(atlasHeight_);
    metrics.atlasWidth = static_cast<float>(glyphWidth_) / static_cast<float>(atlasWidth_);
    metrics.atlasHeight = static_cast<float>(glyphHeight_) / static_cast<float>(atlasHeight_);

    return metrics;
}

bool FontAtlas::hasGlyph(uint32_t codepoint) const {
    // Check ASCII range
    if (codepoint >= firstChar_ && codepoint <= lastChar_) {
        return true;
    }
    // Check box drawing characters (included in JetBrains Mono atlas)
    if (codepoint >= 0x2500 && codepoint < 0x2580) {
        return true;
    }
    return false;
}

// =============================================================================
// UV Coordinate Helpers
// =============================================================================

void FontAtlas::getTextureCoords(uint32_t codepoint,
                                float& u0, float& v0, float& u1, float& v1) const {
    if (codepoint < firstChar_ || codepoint > lastChar_) {
        // Use first character (space) for missing glyphs
        codepoint = firstChar_;
    }

    size_t index = codepoint - firstChar_;
    int row = static_cast<int>(index) / glyphsPerRow_;
    int col = static_cast<int>(index) % glyphsPerRow_;

    u0 = static_cast<float>(col * glyphWidth_) / static_cast<float>(atlasWidth_);
    v0 = static_cast<float>(row * glyphHeight_) / static_cast<float>(atlasHeight_);
    u1 = static_cast<float>((col + 1) * glyphWidth_) / static_cast<float>(atlasWidth_);
    v1 = static_cast<float>((row + 1) * glyphHeight_) / static_cast<float>(atlasHeight_);
}

std::array<float, 4> FontAtlas::getTexCoords(uint32_t codepoint) const {
    std::array<float, 4> coords;
    getTextureCoords(codepoint, coords[0], coords[1], coords[2], coords[3]);
    return coords;
}

// =============================================================================
// Built-in Fonts
// =============================================================================

std::vector<std::string> FontAtlas::getBuiltinFontNames() {
    return {"vga_8x16", "default"};
}

std::vector<std::string> FontAtlas::getUnsciiVariants() {
    return {"unscii-8", "unscii-16", "unscii-16-full"};
}

// =============================================================================
// Unscii Font Loading
// =============================================================================

bool FontAtlas::loadUnsciiFont(const std::string& variant, int pixelSize) {
    NSLog(@"FontAtlas: Loading Unscii font variant: %s", variant.c_str());

    // Try to load pre-generated atlas first
    if (loadUnsciiAtlas(variant, pixelSize)) {
        return true;
    }

    NSLog(@"FontAtlas: Pre-generated atlas not found, falling back to TTF");

    // Fallback to loading TTF directly
    std::string fontPath = findUnsciiAtlasPath(variant);
    if (!fontPath.empty()) {
        // Extract font filename and try to load TTF
        NSString* assetsPath = [[NSBundle mainBundle] pathForResource:@"Assets" ofType:nil];
        if (assetsPath) {
            NSString* fontFile = [NSString stringWithFormat:@"%@/fonts/%s.ttf", assetsPath, variant.c_str()];
            if ([[NSFileManager defaultManager] fileExistsAtPath:fontFile]) {
                return loadTrueTypeFont([fontFile UTF8String], pixelSize > 0 ? pixelSize : (variant == "unscii-8" ? 8 : 16));
            }
        }
    }

    NSLog(@"FontAtlas: Failed to load Unscii variant: %s", variant.c_str());
    return false;
}

bool FontAtlas::loadDefaultUnsciiFont() {
    // Try unscii-16 first (best readability), then unscii-8, then fallback
    if (loadUnsciiFont("unscii-16", 16)) {
        return true;
    }
    if (loadUnsciiFont("unscii-8", 8)) {
        return true;
    }
    // Final fallback to built-in VGA font
    return loadBuiltinFont("vga_8x16");
}

bool FontAtlas::loadUnsciiAtlas(const std::string& variant, int pixelSize) {
    @autoreleasepool {
        // Determine glyph dimensions based on variant
        int glyphW, glyphH;
        if (variant == "unscii-8") {
            glyphW = 8; glyphH = 8;
        } else if (variant == "unscii-16" || variant == "unscii-16-full") {
            glyphW = 8; glyphH = 16;
        } else {
            return false;
        }

        // Construct atlas filename
        NSString* atlasName = [NSString stringWithFormat:@"font_atlas_unscii_%s_%dx%d.png",
                               variant.c_str(), glyphW, glyphH];

        NSBundle* bundle = [NSBundle mainBundle];
        NSString* atlasPath = [[bundle resourcePath] stringByAppendingPathComponent:atlasName];

        if (![[NSFileManager defaultManager] fileExistsAtPath:atlasPath]) {
            NSLog(@"FontAtlas: Atlas not found at: %@", atlasPath);
            return false;
        }

        NSLog(@"FontAtlas: Found Unscii atlas at: %@", atlasPath);

        // Load PNG image
        NSImage* image = [[NSImage alloc] initWithContentsOfFile:atlasPath];
        if (!image) {
            NSLog(@"FontAtlas: Failed to load atlas image");
            return false;
        }

        NSBitmapImageRep* bitmap = [[NSBitmapImageRep alloc] initWithData:[image TIFFRepresentation]];
        if (!bitmap) {
            NSLog(@"FontAtlas: Failed to create bitmap representation");
            return false;
        }

        int width = (int)[bitmap pixelsWide];
        int height = (int)[bitmap pixelsHigh];
        int samplesPerPixel = (int)[bitmap samplesPerPixel];

        NSLog(@"FontAtlas: Atlas dimensions: %dx%d, samples: %d", width, height, samplesPerPixel);

        // Determine if this is an RGBA atlas (new high-res antialiased format)
        bool hasAlpha = (samplesPerPixel == 4 || [bitmap hasAlpha]);
        MTLPixelFormat pixelFormat;
        std::vector<uint8_t> atlasData;
        unsigned char* bitmapData = [bitmap bitmapData];
        int bytesPerRow = (int)[bitmap bytesPerRow];

        if (hasAlpha && samplesPerPixel >= 3) {
            // New RGBA format with antialiasing and transparency
            NSLog(@"FontAtlas: Loading RGBA atlas with alpha transparency");
            pixelFormat = MTLPixelFormatRGBA8Unorm;
            atlasData.resize(width * height * 4);

            // Copy RGBA data directly
            for (int y = 0; y < height; y++) {
                for (int x = 0; x < width; x++) {
                    int dstIdx = (y * width + x) * 4;
                    int srcIdx = y * bytesPerRow + x * samplesPerPixel;

                    if (samplesPerPixel == 4) {
                        // RGBA
                        atlasData[dstIdx + 0] = bitmapData[srcIdx + 0]; // R
                        atlasData[dstIdx + 1] = bitmapData[srcIdx + 1]; // G
                        atlasData[dstIdx + 2] = bitmapData[srcIdx + 2]; // B
                        atlasData[dstIdx + 3] = bitmapData[srcIdx + 3]; // A
                    } else if (samplesPerPixel == 3) {
                        // RGB - add full alpha
                        atlasData[dstIdx + 0] = bitmapData[srcIdx + 0]; // R
                        atlasData[dstIdx + 1] = bitmapData[srcIdx + 1]; // G
                        atlasData[dstIdx + 2] = bitmapData[srcIdx + 2]; // B
                        atlasData[dstIdx + 3] = 255; // A
                    }
                }
            }
        } else {
            // Old grayscale format (fallback for legacy atlases)
            NSLog(@"FontAtlas: Loading grayscale atlas");
            pixelFormat = MTLPixelFormatR8Unorm;
            atlasData.resize(width * height);

            // Convert to grayscale
            for (int y = 0; y < height; y++) {
                for (int x = 0; x < width; x++) {
                    int dstIdx = y * width + x;

                    if (samplesPerPixel == 1) {
                        // Already grayscale
                        int srcIdx = y * bytesPerRow + x;
                        atlasData[dstIdx] = bitmapData[srcIdx];
                    } else {
                        // RGB/RGBA - take first channel
                        int srcIdx = y * bytesPerRow + x * samplesPerPixel;
                        atlasData[dstIdx] = bitmapData[srcIdx];
                    }
                }
            }
        }

        // Set font properties
        glyphWidth_ = glyphW;
        glyphHeight_ = glyphH;
        atlasWidth_ = width;
        atlasHeight_ = height;
        firstChar_ = 32;
        lastChar_ = 126;
        fontName_ = "Unscii " + variant;
        isMonospace_ = true;

        // Atlas layout parameters (from our generator)
        int padding = 4;
        int spacing = 2;
        int paddedCellWidth = glyphW + (padding * 2);
        int paddedCellHeight = glyphH + (padding * 2);
        int cellWidthWithSpacing = paddedCellWidth + spacing;
        int cellHeightWithSpacing = paddedCellHeight + spacing;
        int glyphsPerRow = 16;

        // Use the actual glyph dimensions plus descender space
        // Add extra pixels vertically to capture descenders (g, j, p, q, y, etc.)
        int descenderSpace = 4;  // Additional pixels below baseline for descenders
        int actualGlyphWidth = glyphW;
        int actualGlyphHeight = glyphH + descenderSpace;

        // Build character list: ASCII 32-126 + Box Drawing 0x2500-0x257F
        std::vector<uint32_t> charList;

        // Add ASCII printable characters
        for (uint32_t i = firstChar_; i <= lastChar_; ++i) {
            charList.push_back(i);
        }

        // Add box drawing characters
        for (uint32_t i = 0x2500; i < 0x2580; ++i) {
            charList.push_back(i);
        }

        int charCount = (int)charList.size();
        glyphs_.clear();
        glyphs_.reserve(charCount);
        charMap_.clear();

        NSLog(@"FontAtlas: Building metrics for %d characters", charCount);

        // Generate glyph metrics
        for (int i = 0; i < charCount; ++i) {
            uint32_t codepoint = charList[i];

            int row = i / glyphsPerRow;
            int col = i % glyphsPerRow;

            // Calculate position in spaced atlas - cells are already properly positioned
            int startX = col * cellWidthWithSpacing;
            int startY = row * cellHeightWithSpacing;

            GlyphMetrics metrics;
            metrics.width = actualGlyphWidth;
            metrics.height = actualGlyphHeight;
            metrics.bearingX = 0;
            metrics.bearingY = glyphH;  // Baseline at original glyph height (descenders go below)
            metrics.advance = glyphWidth_;  // Keep original advance for spacing
            // Atlas coordinates: skip padding but sample extra height for descenders
            // Start slightly higher to capture full glyph including descenders
            metrics.atlasX = static_cast<float>(startX + padding) / atlasWidth_;
            metrics.atlasY = static_cast<float>(startY + padding - 1) / atlasHeight_;  // -1 to capture top
            metrics.atlasWidth = static_cast<float>(actualGlyphWidth) / atlasWidth_;
            metrics.atlasHeight = static_cast<float>(actualGlyphHeight) / atlasHeight_;

            glyphs_.push_back(metrics);
            charMap_[codepoint] = i;
        }

        // Create Metal texture with appropriate format
        bool success = createTexture(atlasData.data(), atlasWidth_, atlasHeight_, pixelFormat);

        if (success) {
            NSLog(@"FontAtlas: Successfully loaded Unscii %s - %dx%d glyphs, %d characters, format: %s",
                  variant.c_str(), glyphWidth_, glyphHeight_, charCount,
                  hasAlpha ? "RGBA (antialiased)" : "Grayscale");
        }

        return success;
    }
}

std::string FontAtlas::findUnsciiAtlasPath(const std::string& variant) {
    @autoreleasepool {
        // Determine glyph dimensions
        int glyphW, glyphH;
        if (variant == "unscii-8") {
            glyphW = 8; glyphH = 8;
        } else if (variant == "unscii-16" || variant == "unscii-16-full") {
            glyphW = 8; glyphH = 16;
        } else {
            return "";
        }

        NSString* atlasName = [NSString stringWithFormat:@"font_atlas_unscii_%s_%dx%d.png",
                               variant.c_str(), glyphW, glyphH];

        NSBundle* bundle = [NSBundle mainBundle];
        NSString* atlasPath = [[bundle resourcePath] stringByAppendingPathComponent:atlasName];

        if ([[NSFileManager defaultManager] fileExistsAtPath:atlasPath]) {
            return std::string([atlasPath UTF8String]);
        }

        return "";
    }
}

// =============================================================================
// Private Helper Methods
// =============================================================================

bool FontAtlas::createTexture(const uint8_t* pixels, int width, int height,
                             MTLPixelFormat format) {
    if (!device_ || !pixels || width <= 0 || height <= 0) {
        return false;
    }

    @autoreleasepool {
        MTLTextureDescriptor* descriptor = [MTLTextureDescriptor
            texture2DDescriptorWithPixelFormat:format
            width:width
            height:height
            mipmapped:NO];

        descriptor.usage = MTLTextureUsageShaderRead;
        descriptor.storageMode = MTLStorageModeShared;

        texture_ = [device_ newTextureWithDescriptor:descriptor];
        if (!texture_) {
            return false;
        }

        // Upload pixel data
        MTLRegion region = MTLRegionMake2D(0, 0, width, height);
        NSUInteger bytesPerRow = width * (format == MTLPixelFormatR8Unorm ? 1 : 4);

        [texture_ replaceRegion:region
                    mipmapLevel:0
                      withBytes:pixels
                    bytesPerRow:bytesPerRow];

        atlasWidth_ = width;
        atlasHeight_ = height;

        return true;
    }
}

std::vector<uint8_t> FontAtlas::packGlyphsToAtlas(
    const std::vector<std::vector<uint8_t>>& glyphs,
    int glyphWidth, int glyphHeight) {

    int numGlyphs = static_cast<int>(glyphs.size());
    calculateAtlasDimensions(numGlyphs, glyphWidth, glyphHeight, atlasWidth_, atlasHeight_);

    std::vector<uint8_t> atlasData(atlasWidth_ * atlasHeight_, 0);

    // Add 1 pixel padding between glyphs
    const int padding = 1;
    int cellWidth = glyphWidth + padding;
    int cellHeight = glyphHeight + padding;

    for (size_t i = 0; i < glyphs.size(); ++i) {
        int row = static_cast<int>(i) / glyphsPerRow_;
        int col = static_cast<int>(i) % glyphsPerRow_;

        int startX = col * cellWidth;
        int startY = row * cellHeight;

        // Copy glyph data into atlas
        for (int y = 0; y < glyphHeight; ++y) {
            for (int x = 0; x < glyphWidth; ++x) {
                int atlasX = startX + x;
                int atlasY = startY + y;
                int atlasIndex = atlasY * atlasWidth_ + atlasX;
                size_t glyphIndex = static_cast<size_t>(y * glyphWidth + x);

                if (glyphIndex < glyphs[i].size()) {
                    atlasData[atlasIndex] = glyphs[i][glyphIndex];
                }
            }
        }
    }

    return atlasData;
}

void FontAtlas::calculateAtlasDimensions(size_t numGlyphs, int glyphWidth, int glyphHeight,
                                        int& outWidth, int& outHeight) {
    // Calculate optimal atlas dimensions (power of 2)
    // Try to make it roughly square
    // Add 1 pixel padding between glyphs
    const int padding = 1;
    int cellWidth = glyphWidth + padding;
    int cellHeight = glyphHeight + padding;

    int glyphsPerRow = static_cast<int>(std::ceil(std::sqrt(static_cast<double>(numGlyphs))));
    int rows = static_cast<int>(std::ceil(static_cast<double>(numGlyphs) / glyphsPerRow));

    outWidth = glyphsPerRow * cellWidth;
    outHeight = rows * cellHeight;

    // Round up to next power of 2 for better GPU performance
    outWidth = static_cast<int>(std::pow(2, std::ceil(std::log2(outWidth))));
    outHeight = static_cast<int>(std::pow(2, std::ceil(std::log2(outHeight))));

    glyphsPerRow_ = outWidth / cellWidth;
    glyphRows_ = outHeight / cellHeight;
}

bool FontAtlas::loadVGA8x16Font() {
    fontName_ = "simple_8x16";
    glyphWidth_ = 8;
    glyphHeight_ = 16;
    firstChar_ = 32;  // Start at space
    lastChar_ = 126;  // End at ~
    isMonospace_ = true;

    int charCount = lastChar_ - firstChar_ + 1;

    // Calculate atlas dimensions
    calculateAtlasDimensions(charCount, glyphWidth_, glyphHeight_,
                           atlasWidth_, atlasHeight_);

    // Create atlas texture
    std::vector<uint8_t> atlasData(atlasWidth_ * atlasHeight_, 0);

    // Clear and reserve space for glyph metrics
    glyphs_.clear();
    glyphs_.reserve(charCount);

    // Add 1 pixel padding between glyphs
    const int padding = 1;
    int cellWidth = glyphWidth_ + padding;
    int cellHeight = glyphHeight_ + padding;

    // Generate simple procedural glyphs for each character
    for (int i = 0; i < charCount; ++i) {
        int charIndex = firstChar_ + i;
        int row = i / glyphsPerRow_;
        int col = i % glyphsPerRow_;

        int startX = col * cellWidth;
        int startY = row * cellHeight;

        // Generate simple glyph pattern based on character
        for (int y = 0; y < glyphHeight_; ++y) {
            for (int x = 0; x < glyphWidth_; ++x) {
                int atlasX = startX + x;
                int atlasY = startY + y;
                int atlasIndex = atlasY * atlasWidth_ + atlasX;

                uint8_t pixel = 0;

                // Draw border for all characters
                if (x == 0 || x == 7 || y == 0 || y == 15) {
                    pixel = 128;
                }

                // Draw character code as a simple pattern
                // Numbers 0-9 (48-57)
                if (charIndex >= 48 && charIndex <= 57) {
                    int digit = charIndex - 48;
                    if (y >= 4 && y <= 12 && x >= 2 && x <= 5) {
                        // Fill center for digits
                        if ((y >= 4 + digit) && (y <= 5 + digit)) {
                            pixel = 255;
                        }
                    }
                }
                // Uppercase A-Z (65-90)
                else if (charIndex >= 65 && charIndex <= 90) {
                    if ((x >= 2 && x <= 5) && (y >= 3 && y <= 12)) {
                        // Draw vertical bars
                        if (x == 2 || x == 5) pixel = 255;
                        // Draw horizontal bar
                        if (y == 7 && x >= 2 && x <= 5) pixel = 255;
                        // Draw top bar
                        if (y == 3 && x >= 2 && x <= 5) pixel = 255;
                    }
                }
                // Lowercase a-z (97-122)
                else if (charIndex >= 97 && charIndex <= 122) {
                    if ((x >= 2 && x <= 5) && (y >= 6 && y <= 12)) {
                        // Smaller version
                        if (x == 2 || x == 5) pixel = 255;
                        if (y == 9 && x >= 2 && x <= 5) pixel = 255;
                    }
                }
                // Space - leave empty
                else if (charIndex == 32) {
                    pixel = 0;
                }
                // Other characters - draw a simple pattern
                else {
                    if (x == 3 || x == 4) {
                        if (y >= 4 && y <= 12) pixel = 200;
                    }
                }

                atlasData[atlasIndex] = pixel;
            }
        }

        // Store glyph metrics
        GlyphMetrics metrics;
        metrics.width = glyphWidth_;
        metrics.height = glyphHeight_;
        metrics.bearingX = 0;
        metrics.bearingY = glyphHeight_;
        metrics.advance = glyphWidth_;
        metrics.atlasX = static_cast<float>(startX) / atlasWidth_;
        metrics.atlasY = static_cast<float>(startY) / atlasHeight_;
        metrics.atlasWidth = static_cast<float>(glyphWidth_) / atlasWidth_;
        metrics.atlasHeight = static_cast<float>(glyphHeight_) / atlasHeight_;

        glyphs_.push_back(metrics);
    }

    // Create Metal texture
    return createTexture(atlasData.data(), atlasWidth_, atlasHeight_, MTLPixelFormatR8Unorm);
}

bool FontAtlas::loadC648x8Font() {
    // TODO: Implement C64 font
    return false;
}

bool FontAtlas::loadAppleII8x8Font() {
    // TODO: Implement Apple II font
    return false;
}

} // namespace SuperTerminal
